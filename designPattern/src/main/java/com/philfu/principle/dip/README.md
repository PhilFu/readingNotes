## DIP: Dependence Inversion Principle, 依赖倒置原则
依赖倒置原则: High level modules should not depend upon low level modules. Both should depend upon abstractions.
Abstractions should not depend upon details. Details should depend upon abstraction.

三层含义:
> - 高层模块不应该依赖低层模块,两者都应该依赖其抽象;
> - 抽象不应该依赖细节;
> - 细节应该依赖抽象;

Java中,抽象就是**接口**或**抽象类**,细节就是**实现类**, 面向接口编程。
> - 模块间的依赖通过抽象发生,实现类之间不发生直接的依赖关系,其依赖关系是通过接口或抽象类产生的;
> - 接口或抽象类不依赖于实现类;
> - 实现类依赖接口或抽象类;

Client属于高层业务逻辑,它对底层模块的依赖都建立在抽象上。在新增低层模块时,只修改了业务场景类,也就是高层模块.对低层模块,如Drive类,不需要任何修改,
业务就可以运行,把“变更”引起的风险扩散降低到最低。
**TDD**是依赖倒置原则的最高级应用

依赖的三种写法:
> - 构造器注入: 在类中通过构造函数声明依赖对象
> - setter注入: 在Setter方法中声明依赖关系
> - 接口注入: 在接口的方法中声明依赖对象

#### 最佳实践:
- 每个类尽量都有接口或抽象类,有了抽象才可能依赖倒置。
- 变量的表面类型尽量是接口或者抽象类
- 任何累都不应该从具体类派生,不超过两层的继承是可以容忍的。
- 尽量不要覆写基类的方法,类间依赖的是抽象,覆写了抽象类中已实现的方法,对依赖的稳定性会产生影响
- 结合里氏替换原则使用(父类出现的地方子类就能出现):**接口**负责定义public属性和方法,并且声明与其他对象的依赖关系,**抽象类**负责公共构造部分的实现,
实现类准确的实现业务逻辑,同时在适当的时候对父类进行细化


> 依赖倒置原则是6个设计原则中最难以实现的原则,它是实现开闭原则的重要途径,依赖倒置原则没有实现,就别想实现对扩展开放,对修改封闭。
**面向接口编程**是依赖倒置原则的核心

实际项目中使用依赖倒置原则时要审时度势,不要抓住一个原则不放,每一个原则的优点都是有限度的,并不是放之四海而皆准的真理。