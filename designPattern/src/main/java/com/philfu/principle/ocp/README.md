## OCP: Open Close Principle, 开闭原则
Software entities like classes, modules and functions should be open for extension and closed for modifications.
一个软件实体,如类、模块、函数,应该对扩展开放,对修改关闭。其含义是说一个软件实体应该通过扩展来实现变化,而不是通过修改已有的代码来实现变化。
> 软件实体:项目或软件产品中按照一定的逻辑规则划分的模块; 抽象和类; 方法

开闭原则对扩展开放,对修改封闭,并不意味着不做任何修改,低层模块的变更,必然要有高层模块进行耦合,否则就是一个孤立无意义的代码片段。

变化可以归纳为三类:
> - 逻辑变化。只变化一个逻辑,不涉及其他模块,比如算法由 a*b+c,改为 a*b*c,可以通过修改原有类中的方法来完成,前提是所有依赖或关联类都按照相同逻辑处理
> - 子模块变化。一个模块变化,会对其他模块产生影响,特别是低层次模块的变化。因此通过扩展完成变化时,高层次的模块修改是必然的
> - 可见视图变化。提供给客户使用的界面,该部分的变化会引起连锁反应。按钮文字重新布局倒还简单,业务耦合比较复杂。如原有列表是6列,需要增加一列,
但这一列要跨N张表,处理M个逻辑。但还是可以通过扩展来完成变化,这就需要看原有设计是否灵活

**开闭原则是最基础的一个原则**,其他五个原则都是开闭原则的具体形态。其他五个原则是指导设计的工具和方法,而开闭原则才是精神领袖。

重要性:
> - 对测试的影响。当有变化时,需要考虑一下,原有的健壮代码是否可以不修改,仅通过扩展来实现?否则就要把原有的测试过程回笼一遍,单元测试、功能测试、集成测试甚至验收测试。
单元测试中,一个方法的测试方法不少于3种:首先是正常业务逻辑,其次是边界条件,最后是异常。重要的方法甚至需要十几个测试方法。扩展的话,只需要测试新增的类、方法即可。
> - 开闭原则可以提高复用性。在面向对象的设计中,所有逻辑都是从原子逻辑组合而来的,而不是在一个类中独立实现一个业务逻辑,只有这样才能复用。缩小逻辑粒度,直到不可再分。
> - 开闭原则可以提高可维护性。维护人员不只是对数据维护,还需要对程序进行修改扩展
> - 面向对象开发的要求。万物皆对象,需要把所有的事务都抽象成对象,然后针对对象操作。但万物皆运动,怎么快速应对,需要在设计时考虑所有可能变化的因素。

开闭原则是非常虚的原则,其他五个原则是对开闭原则的解释,如何使用:
> - 抽象约束。抽象是对一组事物的通用描述,没有具体的实现,因此可以有非常多的可能性,随需求变化而变化。通过接口或抽象类可以约束一组可能变化的行为,并且能够实现对扩展开放
有3层含义:第一,通过接口或抽象类约束扩展,对扩展进行边界限定,不允许出现在接口或抽象类中不存在的public方法;第二,参数类型、引用对象尽量使用接口或抽象类,而不是实现类;
第三,抽象类尽量保持稳定,一旦确定即不允许修改。不要有修改接口的思想,除非是彻底的大返工
> - 元数据(metadata)控制模块行为。使用元数据控制程序的行为,减少重复开发。元数据是描述环境和数据的数据,通俗的说是配置参数。达到极致的是控制反转。
> - 指定项目章程。章程指定了所有人员都必须遵守的约定,对项目来说,约定优于配置。
> - 封装变化。两层含义:第一,将相同的变化封装到一个接口或抽象类中;第二,将不同的变化封装到不同的接口或抽象类中。23个设计模式就是从不同的角度对变化进行封装。

最佳实践:
> - 开闭原则也只是一个原则
> - 项目规章非常重要
> - 预知变化